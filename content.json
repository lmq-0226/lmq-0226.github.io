{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"java面向对象总结","slug":"java面向对象总结","date":"2019-10-13T11:15:23.000Z","updated":"2019-10-15T03:24:46.705Z","comments":true,"path":"2019/10/13/java面向对象总结/","link":"","permalink":"http://yoursite.com/2019/10/13/java面向对象总结/","excerpt":"","text":"JAVA面向对象总结面向对象的三大基本特征：继承性，封装性，多态性（一） 封装函数是最小的封装体。类也是一个封装体。private:私有的，权限修饰符，用来修饰类中的成员（成员变量 、成员函数），其只在本类中有效。每个成员变量通常都会对应两个访问方式：一个设置，一个获取。注意：私有仅是封装的一种表现形式。因为语句都必须在函数内，所以，私有化后，再提供访问方式，就可以在访问方式的函数内实现变量控制。这样就提高代码的健壮性。一般进行封装，要对类中的大部分属性都隐藏，最低权限是private。类里有一个setXxx函数（一般返回值是void，保存数据，要带参数）和getXxx函数（有返回值类型，但一般没参数,getXxx之后一般用一个变量来接收:stringx=p.getXxx），那代表一定有一个私有化属性。成员变量都有初始化值， 局部变量可以没有。举例： 1234567891011class demo&#123; private Stringname； public void setName(Stringname)//这个函数方便以后赋值 &#123; this.name=name; &#125; public String getName()//这个函数是方便以后有需要调用的，比如以后要打印name的值 &#123; return name; &#125; 构造函数：函数名与类名一致，不用返回值类型，不可以用return，主要用来初始化对象。对象一建立，就默认调用其构造函数。一个对象一建立，就有其默认的属性和行为。（如一个人刚出生就会呼吸，哭…）。如果我们没有指认，那么类建立就会默认建一个构造函数（类名（）{}），不然对象无法初始化，也就无法建立。（注意：只要我们有重写，那么就不会使用默认的建构造函数）其与普通函数的区别除了写法上之外：1，构造函数只在对象建立时运行一次，不再运行了，而普通函数可以调用多次，另外，构造函数是用来初始化对象的，而一般方法是用来添加对象具备的功能。何时我们要手动添加构造函数：当我们分析事物时，该事物存在一些特性或行为，那么我们就给其定义一个构造函数，如果有变量参与运算，那么我们就给构造函数定义一个参数。 构造函数写法举例： 12345678910class Person&#123; Person(String name,int age)//注意：在新建一个对象时要加上参数进行区分，因为一个类可以放很多个构造方法。//比如调用方式：Person p =new Person（&quot;fada&quot;,20）//构造函数已经被重写了，默//认的构造方法已经不存在了，再调用 Person p=new Person（）；会报错 &#123; this.name = name; this.age = age; &#125; 初始化代码块：（不怎么用）1，所有对象在建立时都先执行构造代码块初始化，再执行构造函数初始化。 2，作用：当所有对象有共性时，那么就可以定义一个构造代码块（例如：所有小孩先出来就是哭，然后才有其它的属性） 构造代码块的写法(就是在类里面用一个大括号)举例： 1234567class Person&#123;&#123;System.out.print(&quot;fada&quot;)//这样一写，那么以后每次建立一个构造函数时便先初始化这个构造代码块&#125;&#125; this关键字的用法This在类中就是三个代表：代表对象的成员变量，在函数中代表对象调用函数，代表类中的构造函数。 格式：this.变量=变量；this是用来区分局部变量和成员变量同名时的关键字，因为如果在构造函数里比如（name=name），那么其是赋值给他本身，而不是赋值给类里面的name。何是用this？当定义类中的函数时，需要调用该函数的对象时，这个时候就用this来表示这个对象。但凡本类功能内部使用到了本类对象，用this表示。看到this就是有代表对象，代表哪个对象就看其所在功能被哪个对象调用。这样就知道谁在参与运算。 例： 1234567891011121314class Person&#123; private String name; Person(String name) &#123; this.name= name;//this.name=p1.name；&#125;&#125;class PersonDemo3 &#123; public static void main(String[] args) &#123;​ Person p1 =new Person(&quot;fada&quot;);​123&#125;&#125; this的应用之定义类中函数的调用：当定义类中功能时，该函数内部要用到调用该函数的对象时，这时用this来表示这个对象。 但凡本类功能内部使用了了本类对象，都用this表示。 例： 1234567891011121314151617181920212223242526class Person&#123;private String name; Person(String name) &#123; this.name= name;//this.name=p1.name；this.fada();//其实就==p1.fada();//这里写这p1是因为p1这个对象在调用这个函数。一句话，谁调用它就在代表谁。&#125;private int age;Person(int age)&#123; this.age =age;&#125;public void fada() &#123; System.out.println(&quot;fada&quot;);&#125;/* 需求：给人定义一个用于比较年龄是否相同的功能。也就是是否是同龄人。 */ public boolean compare(Person p) &#123; return this.age==p.age;​ }​1234567891011121314151617&#125;class PersonDemo&#123; public static void main(String[] args) &#123;​ Person p1 = new Person(20);​ Person p2 = new Person(25);//因为是两个人比，所以要先建立两人的对象 boolean b = p1.compare(p2);//这里定义了一个布尔型变量去接收p1调用compare函数的值 System.out.println(b);&#125;&#125; 二、SUPERsuper关键和this作用类似，是被屏蔽的成员变量或者成员方法或变为可见，或者说用来引用被屏蔽的成员变量和成员成员方法。不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。 Static（静态）关键字：static是一个修饰符：三种修饰：修饰类的变量、方法和构造代码块。静态方法只能直接引用和访问静态变量和方法注意（函数即方法，对象也叫实例）有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static(静态的)就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static成员的最常见的例子是main() 。因为在程序开始执行时必须调用main() ，所以它被声明为static。 声明为static的变量称为静态变量或类变量。可以直接通过类名引用静态变量，也可以通过实例名来引用静态变量，但最好采用前者，因为后者容易混淆静态变量和一般变量。静态变量是跟类相关联的，类的所有实例共同拥有一个静态变量。关键点：静态变量与实例变量的区别：静态变量也叫类变量，为所有对象所共有，所以一个对象的变量值改变，那么所有对象的值一起发生改变。而实例变量则是各自独立的不受影响。 声明为static的方法称为静态方法或类方法。静态方法可以直接调用静态方法，访问静态变量，但是不能直接访问实例变量和实例方法。静态方法中不能使用this关键字，因为静态方法不属于任何一个实例。静态方法不能被子类的静态方法覆盖。特有属性随着对象存储于堆内存中，而static修饰后的属性，存在于方法区.什么时候使用静态修饰符？当对象中出现共享数据时，使用静态修饰。但对象内的特有数据要定义成非静态存在于堆内存中。而对于方法时：当功能内部没有访问到非静态数据时，（即对象的特有数据）那么可以使用静态修饰。静态代码块：用于给类做初始化的。不管有没有对象都执行，只要调用了类里面成员或方法，就会执行，而且优先于主函数，优先执行级别最高。 （二） 继承继承就是将两个类的共性描述提取出来，单独进行描述，从而简化代码，提高复用性。 格式：class 子类名extends 父类名 关健字为extends：继承 JAVA语言中：JAVA只支持单继承，不支持多继承。因为多继承容易带来安全隐患:当多个父类中定义了相同功能， 当功能内容不同时，子类对象不确定要运行哪一个。 但是java保留这种机制。并用另一种体现形式来完成表示。多实现。 子父类中的函数另一个特性：函数的重写(覆盖)当子类继承父类，沿袭了父类的功能，这时不但可以保留父类的功能定义，还可以重写功能内容。 覆盖要注意的关健点：1，子类覆盖父类，必须保证子类访问权限大于等于父类权限，才可以覆盖，否则编译失败。（权限修饰符没设的时候为默认权限，介于public与private之间。） 2，静态只能覆盖静态。 注意： 重载：只看同名函数的参数列表。 重写：子父类方法要一模一样。 final : “最终”修饰符：1，可以修饰类，函数，变量。2，被final修饰的类不可以被继承。作用：为了避免被继承，被子类复写功能。3，被final修饰的方法不可以被复写。4，被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，有可以修饰局部变量。当在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起个名字。方便于阅读。而这个值不需要改变，所以加上final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。5，内部类定义在类中的局部位置上是，只能访问该局部被final修饰的局部变量。例如：final int x=4；那么x永远等于4，不可以被赋值，就成了常量，之所以不直接定常量，是因为要给数值起个名，增强阅读性，以后也好调用。 抽象修饰符，abstract：只能修饰类和方法：特点：1，修饰的类不能创建对象（实例）。2，修饰的对象只有功能，没有内容。3，抽象方法和抽象类都必须被abstract关键字修饰，也就是抽象方法一定在抽象类中，但抽象类不一定要有抽象方法.4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。因为抽象方法和抽象类都必须被abstract关键字修饰（如果只复写了一个，那么子类必然还继承了其它的抽象方法，根据抽象方法必须在抽象类中，则这个类还是个抽象类）。 接口：接口：初期理解，可以认为是一个特殊的抽象类当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。class用于定义类关健字：interface用于定义接口。 接口定义时，格式特点：1，接口中常见定义：常量，抽象方法。2，接口中的成员都有固定修饰符，（不写也会自动生成）。常量：public static final方法：public abstract记住：接口中的成员都是public的。 接口：是不可以创建对象的，因为有抽象方法。需要被子类实现，子类对接口中的抽象方法全都覆盖后，子类才可以实例化。否则子类是一个抽象类。原因和抽象类一样，有抽象则为抽象类。 接口可以被类多实现，也是对多继承不支持的转换形式。java支持多实现。1，类可以实现多个接口，用关健字：implements 如：class Test implements JieKou,JieKou22，类继承后，仍可以实现多个接口，如：class Test extends Demoimplements JieKou,JieKou23，接口在可以实现多继承,如：interface Test extends A,B （三） 多态1，多态的体现父类的引用指向了自己的子类对象。父类的引用也可以接收自己的子类对象。2，多态的前提必须是类与类之间有关系。要么继承，要么实现。通常还有一个前提：存在覆盖。 3，多态的好处多态的出现大大的提高程序的扩展性。 4，多态的弊端：提高了扩展性，但是只能使用父类的引用访问父类中的成员。 1234567891011121314151617181920212223242526272829303132333435363738abstract classAnimal&#123; abstract void eat();&#125;class Cat extendsAnimal&#123; public void eat()//多态还有一个前提：存在覆盖。不然没有意义，只是继承了一个空方法。 &#123; System.out.println(&quot;吃鱼&quot;); &#125;public void catchMouse()//但是只能使用父类的引用访问父类中的成员。因为父类中并没有catchMouse方法，所以多态无法实现catchMouse &#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;class Dog extendsAnimal&#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125;&#125;public static voidfunction(Animal a)//Animal a = new Cat();父类的引用指向了自己的子类对象。父类的引用也可以接收自己的子类对象。前题：必须是类与类之间有关系。要么继承，要么实现。Animal是动物，Cat是它的子类。&#123; a.eat();&#125;class DuoTaiDemo &#123; public static void main(String[] args) &#123; function(new Cat());function(new Dog());//提高了扩展性，不用再去新建一个对象，再引用对象的功能。 &#125; 异常：1.异常的处理 java 提供了特有的固定语句进行处理。 $$try{ 需要被检测的代码；}catch(异常类 变量){ 处理异常的代码；(处理方式)}finally//这句可以没有。{$$ 2.对捕获到的异常对象进行常见方法操作。 StringgetMessage()：获取异常信息。 在函数上声明异常。便于提高安全性，让调用出进行处理。不处理编译失败对多异常的处理。 1，声明异常时，建议声明更为具体的异常。这样处理的可以更具体。2，对方声明几个异常，就对应有几个catch块。不要定义多余的catch块。如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面。 建立在进行catch处理时，catch中一定要定义具体处理方式。不要简单定义一句 e.printStackTrace(),也不要简单的就书写一条输出语句。 自定义异常：必须是自定义类继承Exception，因为异常体系有一个特点就是异常类和异常对象都被抛出，他们要具备可抛性，而这个可抛性是Throwable这个体系中独有特点。只有这个体系中的类和对象才可以被throws和throw操作，二者区别是：throws使用在函数上用，用来抛出异常，告诉调用者这里有可能会出现异常。throw使用在函数内用来抛出异常对象让调用者处理。throws后面跟的异常类。可以跟多个。用逗号隔开。throw后跟的是异常对象。 Exceptoin中有一个特殊的子类异常RuntimeException：运行时异常。如果在函数内容抛出该异常，函数上可以不用声明，编译一样通过。如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过； 之所以不用在函数声明，是因为不需要让调用者处理，当该异常发生，希望程序停止，对代码进行修正。自定义异常时，如果该异常的发生，无法处理让其再继续进行运算，必须修正代码，就让自定义异常继承RuntimeException，如可以处理，则继承Exception。","categories":[],"tags":[]},{"title":"我的第一个博客","slug":"我的第一个博客","date":"2019-10-10T10:28:44.000Z","updated":"2019-10-13T11:17:33.297Z","comments":true,"path":"2019/10/10/我的第一个博客/","link":"","permalink":"http://yoursite.com/2019/10/10/我的第一个博客/","excerpt":"","text":"你好","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-10T09:54:07.370Z","updated":"2019-10-10T09:54:07.371Z","comments":true,"path":"2019/10/10/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}