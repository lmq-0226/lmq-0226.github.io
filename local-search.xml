<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Eclipse环境下如何配置Tomcat，并且把项目部署到Tomcat服务器上</title>
    <link href="undefined2019/10/24/Eclipse%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AETomcat%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%8A%8A%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <url>2019/10/24/Eclipse%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AETomcat%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%8A%8A%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>Eclipse环境下如何配置Tomcat</p><p>在本小节中，我将详细介绍在Eclipse环境中怎样集成Tomcat。<br>现在Tomcat分了好多个版本，需要注意的是这里我只会用到Tomcat8，而Tomcat8又细分了好多个版本，<br>记得2016年时我就用的是Tomcat8.0.36，按现在2019年2月28号的最新时间来算，Tomcat8已经升级到Tomcat8.5.38这个版本了，<br>所以这两个版本的Tomcat我都会教大家一步一步集成到Eclipse中来。</p><h2 id="Eclipse环境下配置Tomcat8-0-36"><a href="#Eclipse环境下配置Tomcat8-0-36" class="headerlink" title="Eclipse环境下配置Tomcat8.0.36"></a>Eclipse环境下配置Tomcat8.0.36</h2><ol><li>打开Eclipse，单击“Window”菜单，选择下方的“Preferences”。 </li></ol><p><img src="/img/Tomcat1.jpg" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>单击“Server”选项，选择下方的“Runtime Environments”。 </li></ol><p><img src="/img/Tomcat2.jpg" srcset="/img/loading.gif" alt=""></p><p>3.点击“Add”添加Tomcat。 </p><p><img src="/img/Tomcat3.jpg" srcset="/img/loading.gif" alt=""></p><ol start="4"><li>点击“Next”，选中自己安装的Tomcat路径 .</li></ol><p><img src="/img/Tomcat4.jpg" srcset="/img/loading.gif" alt=""></p><ol start="5"><li>点击“Finish”完成 .</li></ol><p><img src="/img/Tomcat5.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="Eclipse环境下配置Tomcat8-5-38"><a href="#Eclipse环境下配置Tomcat8-5-38" class="headerlink" title="Eclipse环境下配置Tomcat8.5.38"></a>Eclipse环境下配置Tomcat8.5.38</h2><ol><li>打开Eclipse，单击“Window”菜单，选择下方的“Preferences” .</li></ol><p><img src="/img/Tomcat6.jpg" srcset="/img/loading.gif" alt=""></p><p>​<br>2.单击“Server”选项，选择下方的“Runtime Environments”。 </p><p><img src="/img/Tomcat7.jpg" srcset="/img/loading.gif" alt=""></p><ol start="3"><li>点击“Add”添加Tomcat .</li></ol><p><img src="/img/Tomcat8.jpg" srcset="/img/loading.gif" alt=""></p><ol start="4"><li>点击“Next”，选中自己安装的Tomcat路径。 </li></ol><p><img src="/img/Tomcat9.jpg" srcset="/img/loading.gif" alt=""></p><p> 从上图可以发现，在Eclipse集成Tomcat时，遇到了一个报错： </p><p>​    <strong>The Apache Tomcat installation at this directory is version 8.5.38. A Tomcat 8.0 installation is expected</strong> </p><p>这里我的Tomcat的版本是8.5.38，报这个错的原因是Eclipse里面限制Tomcat的最高版本是8.0的，我用的Tomcat的版本明显高于Eclipse的要求。<br>具体的改法如下：<br>首先找到Tomcat的本地安装路径，然后找到lib文件夹中的catalina.jar包，用解压软件打开这个jar包，<br>依次找到并且双击打开catalina.jar\org\apache\catalina\util\ServerInfo.properties文件，如下所示：<br><img src="/img/Tomcat10.jpg" srcset="/img/loading.gif" alt=""></p><p>将文件中server.info=Apache Tomcat/8.5.38中的8.5.38改成8.0.0即可。</p><p>修改完成后重新配置Tomcat就不会报错了，如下图所示。 </p><p><img src="/img/Tomcat11.jpg" srcset="/img/loading.gif" alt=""></p><p>5.点击“Finish”完成。 </p><p><img src="/img/Tomcat12.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="建立一个Web应用"><a href="#建立一个Web应用" class="headerlink" title="建立一个Web应用"></a>建立一个Web应用</h1><ol><li><code>File</code> → <code>New</code> → <code>Dynamic Web Project</code> </li></ol><p><img src="/img/Tomcat13.jpg" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>创建一个<code>Dynamic Web Project</code> </li></ol><p><img src="/img/Tomcat14.jpg" srcset="/img/loading.gif" alt=""></p><ol start="3"><li>点击“Next”下一步 </li></ol><p><img src="/img/Tomcat15.jpg" srcset="/img/loading.gif" alt=""></p><ol start="4"><li>点击“Next”下一步 </li></ol><p><img src="/img/Tomcat16.jpg" srcset="/img/loading.gif" alt=""></p><ol start="5"><li>点击“Finish”完成 </li></ol><p><img src="/img/Tomcat17.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat中"><a href="#让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat中" class="headerlink" title="让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat中"></a>让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat中</h2><ol><li><code>Window</code> → <code>Show View</code> → <code>Servers</code> </li></ol><p><img src="/img/Tomcat18.jpg" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>点击链接<code>No servers are available. Click ths link to create a new server.</code> ，在弹出的对话框中选择Tomcat版本 </li></ol><p><img src="/img/Tomcat19.jpg" srcset="/img/loading.gif" alt=""></p><p>3.点击“Next”，添加我们的项目 </p><p><img src="/img/Tomcat20.jpg" srcset="/img/loading.gif" alt=""></p><p>选中项目并点击Add，或是双击都可以添加到右边</p><p>4.点击“Finish”完成</p><p><img src="/img/Tomcat21.jpg" srcset="/img/loading.gif" alt=""></p><p>返回下方的“Servers”面板，右键单击该面板中的“Tomcat v8.0 Server at localhost”节点，<br>在弹出的快捷菜单中单击“Start”，即可启动指定的Web服务器。如果此时直接启动访问<a href="http://localhost:8080/day05" target="_blank" rel="noopener">http://localhost:8080/day05</a> ，会发现会报404的错误。<br>这是因为我们没有添加主页，下面添加主页(index.jsp)的内容：<br><img src="/img/24.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>注意：web资源一定要在WebRoot目录下添加</strong>。如图： </p><p><img src="/img/Tomcat22.jpg" srcset="/img/loading.gif" alt=""></p><p>此时，再一次来访问该链接：<code>http://localhost:8080/day05</code> ，效果如下： </p><p><img src="/img/Tomcat23.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>methods</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub主题更改步骤</title>
    <link href="undefined2019/10/20/GitHub%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%94%B9%E6%AD%A5%E9%AA%A4/"/>
    <url>2019/10/20/GitHub%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%94%B9%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p><strong><em>GitHub主题更改</em></strong></p><p> 首先在浏览器<a href="https://hexo.io/themes/进入github官方主题界面，如图：" target="_blank" rel="noopener">https://hexo.io/themes/进入github官方主题界面，如图：</a> </p><p><img src="/img/1.png" srcset="/img/loading.gif" alt=""></p><p> 里面有非常多的主题，选择一个自己喜欢的，直接点击当前主题的名字 ，就比如说我选择了这个，如图：</p><p><img src="/img/4.png" srcset="/img/loading.gif" alt=""></p><p>点击完之后，进入博主的仓库。点击红笔圈中的绿色按钮，复制红色线上的网址。</p><p><img src="/img/5.png" srcset="/img/loading.gif" alt=""></p><p>后面的步骤就简单了</p><p> 先复制仓库下载主题 ：</p><p><img src="/img/2.png" srcset="/img/loading.gif" alt=""></p><p> 下载完之后会在themes 目录下生成一个名为Mic_Theme文件  </p><p><img src="/img/6.png" srcset="/img/loading.gif" alt=""></p><p>  更改一下hexo工程目录下的配置文件_config.yml，主题名修改一下即可 </p><p><img src="/img/7.png" srcset="/img/loading.gif" alt=""></p><p>然后我们可以先清理一下缓存（清不清理都可以）</p><p><img src="/img/8.png" srcset="/img/loading.gif" alt=""></p><p> 然后重新生成datebase： </p><p><img src="/img/9.png" srcset="/img/loading.gif" alt=""></p><p> 打开本地仓库服务： </p><p><img src="/img/11.png" srcset="/img/loading.gif" alt=""></p><p>浏览器打开本地仓库（localhost:4000），你会发现本地仓库已经变为自己    刚刚更改的主题了 。（但是此时还没有传到远程仓库。）</p><p><strong>部署GItHub服务器</strong></p><p>此处我们采用git命令来完成部署的工作。</p><p>（1）、cd d:/hexo/blog  #切换到你的blog文件夹目录（这里是D盘）（.deploy前有一个空格）</p><p>（2）、git clone  <a href="https://github.com/fang235/fang235.github.io" target="_blank" rel="noopener">https://github.com/自己博客名称/自己博客名称.github.io </a>  .deploy/自己博客名称.github.io</p><p><img src="/img/12.png" srcset="/img/loading.gif" alt=""></p><p>需要部署的时候，执行第三个步骤。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p><p><strong>验证</strong></p><p>打开浏览器，输入地址：https://自己博客名称.github.io/ ，就可以看到我们的博客上线了哈哈哈！！！（主题更改后可能要等待一段时间，不要着急）。</p>]]></content>
    
    
    <categories>
      
      <category>methods</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL创建数据库</title>
    <link href="undefined2019/10/20/MySQL%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E5%91%BD%E4%BB%A4/"/>
    <url>2019/10/20/MySQL%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>MySQL**</strong>数据库增删改查<strong><strong>SQL</strong></strong>语句** </p><p><strong>查看数据库</strong> </p><p><strong>使用数据库</strong> </p><p><strong>创建数据库</strong> </p><p><strong>删除数据库</strong> </p><p><strong>创建表</strong> </p><p><strong>长度区别</strong> </p><p>int类型带长度：不影响存取值，即使设定的值超出了长度的范畴，也能存，如果没有达到设定的长度， </p><p>则使用空格自动填充到设定的长度 </p><p>char类型：不可变字符，设定的长度就是规定当前字段能存的数据的最大长度，若超出长度，则会报 </p><p>错，若没有达到长度，使用空格填充到设定的长度 </p><p>varchar：可变字符，设定的长度同样是规定当前字段能存的数据的最大长度，若超出长度，则会报 </p><p>错，若没有达到长度，不会使用空格填充，实际多长就是多长 </p><p><strong>删除表</strong> </p><p><strong>表约束</strong> </p><p>1.非空约束 NOT NULL </p><p>2.默认值约束 DEFAULT ‘男’ </p><p>3.唯一约束 UNIQUE4.主键约束 PRIMARY KEY </p><p>show databases; </p><p>use 数据库名; </p><p>CREATE DATABASE 数据库名; </p><p>DROP DATABASE 数据库名; </p><p>create table 表名( 列名1 类型(长度) [约束], 列名2 类型(长度) [约束], ……); </p><p>DROP TABLE 表名;<strong>查看表结构</strong> </p><p>DESC 表名 </p><p><strong>修改表</strong> </p><p><strong>修改列名</strong> </p><p><strong>修改列类型</strong> </p><p><strong>修改列类型</strong> </p><p><strong>==============================**</strong>数据查询<strong><strong>-</strong></strong>单表<strong>**=================================</strong> </p><p><strong>查询表中全部信息</strong> </p><p><strong>查询表中指定列的信息</strong> </p><p>语句的执行顺序：from—&gt;select </p><p><strong>数据去重</strong> </p><p><strong>拼接结果</strong> </p><p><strong>运算符优先级：</strong> </p><p>1.乘法和除法的优先级高于加法和减法 </p><p>2.同级运算的顺序是从左到右 </p><p>3.表达式中使用”括号”可强行改变优先级的运算顺序 </p><p><strong>设置别名**</strong>(<strong><strong>注意：关键字</strong></strong>as<strong><strong>可以省略</strong></strong>)** </p><p>语句的执行顺序：from—&gt;select </p><p>Alter table 表名 change 列名 新列名 类型; </p><p>Alter table 表名 change 列名 列名 新类型; </p><p>Alter table 表名 modify 列名 新类型; </p><p>select * from 表名; </p><p>select 列1,列2 from 表名; </p><p>select distinct 列…. From 表名; </p><p>select concat(列1,列2) from 表名; </p><p>select 列1[+-*/]列2 from 表名; </p><p>select 列 as 别名 from 表名; </p><p>select 列 别名 from 表名;<strong>条件查询</strong> </p><p><strong>条件中比较运算符：**</strong>(** <strong>等于**</strong>:=** <strong>大于**</strong>:&gt;** <strong>大于等于**</strong>:&gt;=** <strong>小于**</strong>:&lt;** <strong>小于等于**</strong>:&lt;=** <strong>不等于**</strong>:!=** <strong>或</strong> <strong>&lt;&gt; )</strong> </p><p>注意:字符串、日期需使用单引号括起来 </p><p>语句的执行顺序：from—&gt;where—&gt;select </p><p><strong>逻辑运算符**</strong>(** <strong>并且**</strong>:and** <strong>或</strong> <strong>&amp;&amp;</strong> <strong>或**</strong>:or** <strong>非**</strong>:not** <strong>或</strong> <strong>! )</strong> </p><p><strong>范围查询</strong> </p><p>//列在这个区间的值where 列 not between 条件1 and 条件2; </p><p>//不在这个区间where !( 列 between 条件1 and 条件2 ); </p><p>//同样表示不在这个区间 </p><p><strong>集合查询**</strong>(** <strong>判断列的值是否在指定的集合中</strong> <strong>)</strong> </p><p>//列中的数据是in后的值里面的where 列 not in(值1,值2); </p><p>//不是in中指定值的数据 </p><p><strong>NULL**</strong>值查询<strong>**(</strong> <strong>注意：列中值为**</strong>null<strong><strong>不能使用</strong></strong>=<strong>**去查询</strong> <strong>)</strong> </p><p>//查询列中值为null的数据 </p><p><strong>模糊查询</strong> </p><p><strong>%**</strong>：表示<strong><strong>0</strong></strong>到多个字符，示例：** </p><p> //表示以0结尾where 列 like ‘0%’; </p><p>//表示以0开头where 列 like ‘%0%’; </p><p> //表示数据中包含0 </p><p><strong>_**</strong>：表示一个字符，可多次使用，示例：** </p><p>select 列… from 表名 where 条件; </p><p>where 列 比较运算符 值; </p><p>where 条件1 逻辑运算符 条件2; </p><p>where not 条件; </p><p>where 列 between 条件1 and 条件2; </p><p>where 列 in(值1,值2); </p><p>where 列 is null; </p><p>where 列 like ‘%0’; </p><p>where 列 like ‘%0_’;//数据结尾第二位是0 </p><p><strong>结果排序**</strong>(** <strong>对查询出的结果按照一列或多列进行升序还是降序排列 升序**</strong>:asc** <strong>降序**</strong>:desc** <strong>注意：不能使用</strong> </p><p><strong>中文的别名排序**</strong>)** </p><p>where 条件 order by 列 [asc/desc] </p><p>语句的执行顺序：from—&gt;where—&gt;select—&gt;order by </p><p><strong>分页查询**</strong>( beginIndex:<strong>**表示从第多少条数据开始</strong> <strong>pageSize:**</strong>表示每页显示的数据条数** <strong>)</strong> </p><p>where [条件] limit beginIndex,pageSize; </p><p>ex：每页显示3条数据 </p><p>第一页: SELECT * FROM 表名 LIMIT 0,3 –0,1,2 </p><p>第二页: SELECT * FROM 表名 LIMIT 3,3 –3,4,5 </p><p>第三页: SELECT * FROM 表名 LIMIT 6,3 –6,7,8 </p><p>第四页: SELECT * FROM 表名 LIMIT 9,3 –9,10,11  </p><p> …… </p><p>第七页: SELECT * FROM 表名 LIMIT 18,3 –18,19,20 </p><p><strong>beginIndex**</strong>公式：<strong><strong>(</strong></strong>当前页数<strong>*<em>-1)\</em>pageSize</strong> </p><p><strong>聚集函数**</strong>(** <strong>作用于一组数据，并对一组数据返回一个值</strong> <strong>)</strong> </p><p><strong>COUNT:**</strong>统计结果记录数，若统计的是列，列中为<strong><strong>Null</strong></strong>，那么<strong><strong>count</strong></strong>将不会计算值** </p><p><strong>MAX:</strong> <strong>统计计算最大值</strong> </p><p><strong>MIN:</strong> <strong>统计计算最小值</strong> </p><p><strong>SUM:</strong> <strong>统计计算求和</strong> </p><p><strong>AVG:</strong> <strong>统计计算平均值</strong> </p><p><strong>分组函数**</strong>(** <strong>注意：如果要对分组后的数据进行筛选，那么必须使用**</strong>having<strong><strong>关键字，条件写在</strong></strong>having<strong>**后</strong> <strong>)</strong> </p><p>select 聚集函数 from 表名 where [条件] group by 列 having 分组后的条件 </p><p>语句的执行顺序：FROM—&gt; WHERE—&gt;group by—-&gt;Having—&gt;SELECT–&gt;ORDER BY </p><p><strong>Where**</strong>和<strong><strong>having</strong></strong>的区别：** </p><p><strong>Where:</strong> <strong>先过滤已有的数据**</strong>(<strong><strong>数据是已经存在的</strong></strong>),<strong><strong>在进行分组</strong></strong>,<strong>**在聚集计算</strong> </p><p><strong>Having:**</strong>先分组<strong><strong>,</strong></strong>在对每组进行计算<strong><strong>,</strong></strong>根据得到结果在过滤<strong><strong>(</strong></strong>分组把数据算出之后，在过滤<strong>**)</strong> </p><p>注意：使用having的时候，它是可以使用别名的 </p><p><strong>===============================**</strong>数据查询<strong><strong>-</strong></strong>多表<strong>**===============================</strong> </p><p><strong>交叉连接**</strong>:<strong>**又名笛卡尔积，使用交叉连接会产生笛卡尔积</strong> </p><p>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。 </p><p>select * from 表1,表2<strong>内连接：过滤为空的数据**</strong>(<strong><strong>查询的实际上是两张表数据的交集部分</strong></strong>)** <strong>目的</strong> <strong>==**</strong>》解决笛卡尔积现象，正确** </p><p><strong>查询了需要的数据</strong> </p><p>select * from 表1,表2 where 表1.字段=表2.字段; </p><p>//隐式内连接,使用where条件消除笛卡尔积 </p><p>select * from 表1 [inner] join 表2 on 表1.字段=表2.字段; </p><p> //显式内连接,如果是多张表，则一直在join..on后依次添加join..on即可,inner关键字可被省略 </p><p><strong>外连接：左外连接、右外连接、全外连接</strong> </p><p><strong>左外连接**</strong>:<strong><strong>以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为</strong></strong>NULL<strong>**，请参考实际查询</strong> </p><p><strong>结果来理解</strong> </p><p>select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段; </p><p>//表1为左表，表2为右表,outer关键字可被省略 </p><p><strong>右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为**</strong>NULL<strong>**，结合实际查询结</strong> </p><p><strong>果来理解</strong> </p><p>select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段; </p><p>//表1为左表，表2为右表,outer关键字可被省略 </p><p><strong>全外连接：返回涉及的多表中的所有数据，**</strong>MYSQL<strong>**中不支持该查询，仅限了解自连接：单表当作多表</strong> </p><p><strong>查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一</strong> </p><p><strong>定要使用别名</strong> </p><p>多用在分类数据、省市县分类数据、权限… </p><p>select 表1.字段1,表2.字段2 from 表名 as 表1,表名 as 表2 where 表1.字段1=表2.字段2 </p><p><strong>子查询：将一个查询结果作为另一个查询的对象，直白的讲就是**</strong>SQL<strong>**语句嵌套</strong> </p><p>select * from (select * from 表名) as 别名select * from where 条件 </p><p>//条件中包含查询语句 </p><p>注意：1.查询结果的虚拟表必须取别名 </p><p> 2.字段与关键字一样，冲突时，需要给字段名加``,(Esc键下面、1的左边) </p><p> 3.如果给虚拟结果表中的字段取了别名，则对虚拟结果表查询时，应该用 表别名.虚拟表字段别名 </p><p><strong>===============================**</strong>插入数据<strong>**===============================</strong> </p><p>insert into 表名(字段1,字段2..) values(值1,值2…); </p><p>注意： 1.如果插入的表中的主键是自增类型的，可以不用插入值 </p><p> 2.如果主键是非自增 ，插入的数据则是填补主键字段值空余的值 </p><p> 3.如果主键设置了自动递增，会从主键字段最大值开始插入数据 </p><p><strong>其他插入方式：</strong>insert into 表名(字段1,字段2) values(值1,值2),(值1,值2); </p><p>//插入多条数据【MYSQL】insert into 表名 values(值1,值2); </p><p>//针对全表所有字段进行插入操作insert into 表名(字段) select 字段 from 表2; </p><p>//查询结果插入insert into 表名 select 字段 from 表2; </p><p>//查询结果，全表插入 </p><p><strong>===============================**</strong>修改数据<strong>**===============================</strong> </p><p>update 表 set 字段=值 where 条件; </p><p> //带条件修改指定数据，否则修改全表 </p><p><strong>===============================**</strong>删除数据<strong>**===============================</strong> </p><p>delete from 表 where 条件; </p><p>//删除数据带条件指定数据，否则删除全表数据 </p><p><strong>===============================**</strong>数据备份<strong>**===============================</strong> </p><p><strong>在命令行窗口进行，若操作系统版本高，则使用管理员模式</strong> </p><p>导出： </p><p>mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地 </p><p>ex: mysqldump -uroot -proot jdbcdemo&gt; C:/shop_bak.sql </p><p>导入： </p><p>mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址 </p><p>ex: mysql -uroot -proot jdbcdemo&lt; C:/shop_bak.sql </p><p>使用可视化导入导出： </p><p>Navicat工具的导入和导出/Navicat工具的备份和还原 </p><p><strong>===============================**</strong>数据索引<strong>**===============================</strong> </p><p><strong>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</strong> </p><p><strong>什么列适合建索引？？</strong> </p><p>1.表的主键、外键必须有索引； </p><p>2.数据量超过30000的表应该有索引； </p><p>3.经常与其他表进行连接的表，在连接字段上应该建立索引； </p><p>4.经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； </p><p>5.索引应该建在选择性高的字段上； </p><p>6.索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </p><p><strong>sql**</strong>语句创建和删除索引：** </p><p>创建索引: </p><p>CREATE INDEX 索引名称 ON 表名 (列名) </p><p>删除索引: </p><p>方式一：DROP INDEX 索引名 ON 表名 </p><p>方式二: </p><p>ALTER TABLE 表名 DROP INDEX 索引名</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一个博客</title>
    <link href="undefined2019/10/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>JAVA面向对象总结<br>面向对象的三大基本特征：继承性，封装性，多态性<br>（一） 封装<br>函数是最小的封装体。类也是一个封装体。<br>private:私有的，权限修饰符，用来修饰类中的成员（成员变量 、成员函数），其只在本类中有效。<br>每个成员变量通常都会对应两个访问方式：一个设置，一个获取。<br>注意：私有仅是封装的一种表现形式。<br>因为语句都必须在函数内，所以，私有化后，再提供访问方式，就可以在访问方式的函数内实现变量控制。这样就提高代码的健壮性。<br>一般进行封装，要对类中的大部分属性都隐藏，最低权限是private。<br>类里有一个setXxx函数（一般返回值是void，保存数据，要带参数）和getXxx函数（有返回值类型，但一般没参数,getXxx之后一般用一个变量来接收:stringx=p.getXxx），那代表一定有一个私有化属性。<br>成员变量都有初始化值， 局部变量可以没有。<br>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class  demo&#123;</span><br><span class="line">       private Stringname；</span><br><span class="line">       public void setName(Stringname)//这个函数方便以后赋值</span><br><span class="line">       &#123;</span><br><span class="line">              this.name=name;</span><br><span class="line">       &#125;</span><br><span class="line">       public String getName()//这个函数是方便以后有需要调用的，比如以后要打印name的值</span><br><span class="line">       &#123;</span><br><span class="line">              return name;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数：<br>函数名与类名一致，不用返回值类型，不可以用return，主要用来初始化对象。<br>对象一建立，就默认调用其构造函数。一个对象一建立，就有其默认的属性和行为。（如一个人刚出生就会呼吸，哭…）。<br>如果我们没有指认，那么类建立就会默认建一个构造函数（类名（）{}），不然对象无法初始化，也就无法建立。（注意：只要我们有重写，那么就不会使用默认的建构造函数）<br>其与普通函数的区别除了写法上之外：<br>1，构造函数只在对象建立时运行一次，不再运行了，而普通函数可以调用多次，另外，构造函数是用来初始化对象的，而一般方法是用来添加对象具备的功能。<br>何时我们要手动添加构造函数：当我们分析事物时，该事物存在一些特性或行为，那么我们就给其定义一个构造函数，如果有变量参与运算，那么我们就给构造函数定义一个参数。</p><p>构造函数写法举例：<br>class Person<br>{<br>       Person(String name,int age)<br>//注意：在新建一个对象时要加上参数进行区分，因为一个类可以放很多个构造方法。<br>//比如调用方式：Person p =new Person（”fada”,20）//构造函数已经被重写了，默//认的构造方法已经不存在了，再调用<br> Person p=new Person（）；会报错</p><p>​        {<br>​              this.name = name;<br>​              this.age = age;<br>​       }<br>初始化代码块：（不怎么用）<br>1，所有对象在建立时都先执行构造代码块初始化，再执行构造函数初始化。</p><p>2，作用：当所有对象有共性时，那么就可以定义一个构造代码块（例如：所有小孩先出来就是哭，然后才有其它的属性）</p><p>构造代码块的写法(就是在类里面用一个大括号)举例：<br>class Person{<br>    System.out.print(“fada”)；<br>    //这样一写，那么以后每次建立一个构造函数时便先初始化这个构造代码块<br>}<br>this关键字的用法<br>This在类中就是三个代表：代表对象的成员变量，在函数中代表对象调用函数，代表类中的构造函数。</p><p>格式：this.变量=变量；<br>this是用来区分局部变量和成员变量同名时的关键字，因为如果在构造函数里比如（name=name），那么其是赋值给他本身，而不是赋值给类里面的name。<br>何是用this？当定义类中的函数时，需要调用该函数的对象时，这个时候就用this来表示这个对象。<br>但凡本类功能内部使用到了本类对象，用this表示。<br>看到this就是有代表对象，代表哪个对象就看其所在功能被哪个对象调用。<br>这样就知道谁在参与运算。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">       private String name;</span><br><span class="line">       Person(String name) &#123;</span><br><span class="line">              this.name= name;//this.name=p1.name；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class PersonDemo3 &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">          Person p1 =new Person(&quot;fada&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this的应用之定义类中函数的调用：当定义类中功能时，该函数内部要用到调用该函数的对象时，这时用this来表示这个对象。</p><p>this的应用之定义类中函数的调用：当定义类中功能时，该函数内部要用到调用该函数的对象时，这时用this来表示这个对象。</p><p> 但凡本类功能内部使用了了本类对象，都用this表示。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">private String name;</span><br><span class="line">    Person(String name)&#123;</span><br><span class="line">        this.name= name;//this.name=p1.name；</span><br><span class="line">this.fada();//其实就==p1.fada();</span><br><span class="line">//这里写这p1是因为p1这个对象在调用这个函数。一句话，谁调用它就在代表谁。</span><br><span class="line">&#125;</span><br><span class="line">private int age;</span><br><span class="line">Person(int age)&#123;</span><br><span class="line">     this.age =age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void fada()&#123;</span><br><span class="line">              System.out.println(&quot;fada&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">       需求：给人定义一个用于比较年龄是否相同的功能。也就是是否是同龄人。</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">public boolean compare(Person p) &#123; </span><br><span class="line">              return this.age==p.age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonDemo&#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">          Person p1 = new Person(20);</span><br><span class="line">          Person p2 = new Person(25);</span><br><span class="line">  //因为是两个人比，所以要先建立两人的对象</span><br><span class="line">          boolean b = p1.compare(p2);</span><br><span class="line">          //这里定义了一个布尔型变量去接收p1调用compare函数的值</span><br><span class="line">          System.out.println(b);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、SUPER<br>super关键和this作用类似，是被屏蔽的成员变量或者成员方法或变为可见，或者说用来引用被屏蔽的成员变量和成员成员方法。<br>不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。</p><p>Static（静态）关键字：<br>static是一个修饰符：<br>三种修饰：修饰类的变量、方法和构造代码块。静态方法只能直接引用和访问静态变量和方法<br>注意（函数即方法，对象也叫实例）<br>有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static(静态的)就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static<br>成员的最常见的例子是main() 。因为在程序开始执行时必须调用main() ，所以它被声明为static。　　声明为static的变量称为静态变量或类变量。可以直接通过类名引用静态变量，也可以通过实例名来引用静态变量，但最好采用前者，因为后者容易混淆静态变量和一般变量。静态变量是跟类相关联的，类的所有实例共同拥有一个静态变量。关键点：静态变量与实例变量的区别：静态变量也叫类变量，为所有对象所共有，所以一个对象的变量值改变，那么所有对象的值一起发生改变。<br>而实例变量则是各自独立的不受影响。<br>　声明为static的方法称为静态方法或类方法。静态方法可以直接调用静态方法，访问静态变量，但是不能直接访问实例变量和实例方法。静态方法中不能使用this关键字，因为静态方法不属于任何一个实例。静态方法不能被子类的静态方法覆盖。<br>特有属性随着对象存储于堆内存中，而static修饰后的属性，存在于方法区.<br>什么时候使用静态修饰符？<br>当对象中出现共享数据时，使用静态修饰。<br>但对象内的特有数据要定义成非静态存在于堆内存中。<br>而对于方法时：<br>当功能内部没有访问到非静态数据时，（即对象的特有数据）<br>那么可以使用静态修饰。<br>静态代码块：<br>用于给类做初始化的。不管有没有对象都执行，只要调用了类里面成员或方法，就会执行，而且优先于主函数，优先执行级别最高。</p><p>（二） 继承<br>继承就是将两个类的共性描述提取出来，单独进行描述，从而简化代码，提高复用性。</p><p>格式：class 子类名extends 父类名</p><p>关健字为extends：继承</p><p>JAVA语言中：JAVA只支持单继承，不支持多继承。<br>因为多继承容易带来安全隐患:当多个父类中定义了相同功能，</p><p>当功能内容不同时，子类对象不确定要运行哪一个。</p><p>但是java保留这种机制。并用另一种体现形式来完成表示。多实现。</p><p>子父类中的函数另一个特性：函数的重写(覆盖)<br>当子类继承父类，沿袭了父类的功能，这时不但可以保留父类的功能定义，还可以重写功能内容。</p><p>覆盖要注意的关健点：<br>1，子类覆盖父类，必须保证子类访问权限大于等于父类权限，才可以覆盖，否则编译失败。<br>（权限修饰符没设的时候为默认权限，介于public与private之间。）</p><p>2，静态只能覆盖静态。</p><p>注意：</p><p>重载：只看同名函数的参数列表。</p><p>重写：子父类方法要一模一样。</p><p>final : “最终”修饰符：<br>1，可以修饰类，函数，变量。<br>2，被final修饰的类不可以被继承。作用：为了避免被继承，被子类复写功能。<br>3，被final修饰的方法不可以被复写。<br>4，被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，有可以修饰局部变量。<br>当在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起个名字。方便于阅读。<br>而这个值不需要改变，所以加上final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。<br>5，内部类定义在类中的局部位置上是，只能访问该局部被final修饰的局部变量。<br>例如：<br>final int x=4；那么x永远等于4，不可以被赋值，就成了常量，之所以不直接定常量，是因为要给数值起个名，增强阅读性，以后也好调用。</p><p>抽象修饰符，abstract：只能修饰类和方法：<br>特点：<br>1，修饰的类不能创建对象（实例）。<br>2，修饰的对象只有功能，没有内容。<br>3，抽象方法和抽象类都必须被abstract关键字修饰，也就是抽象方法一定在抽象类中，<br>但抽象类不一定要有抽象方法.<br>4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。<br>如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。因为抽象方法和抽象类都必须被abstract关键字修饰（如果只复写了一个，那么子类必然还继承了其它的抽象方法，根据抽象方法必须在抽象类中，则这个类还是个抽象类）。</p><p>接口：<br>接口：初期理解，可以认为是一个特殊的抽象类<br>当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。<br>class用于定义类<br>关健字：interface<br>用于定义接口。</p><p>接口定义时，格式特点：<br>1，接口中常见定义：常量，抽象方法。<br>2，接口中的成员都有固定修饰符，（不写也会自动生成）。<br>常量：public static final<br>方法：public abstract<br>记住：接口中的成员都是public的。</p><p>接口：是不可以创建对象的，因为有抽象方法。<br>需要被子类实现，子类对接口中的抽象方法全都覆盖后，子类才可以实例化。<br>否则子类是一个抽象类。原因和抽象类一样，有抽象则为抽象类。</p><p>接口可以被类多实现，也是对多继承不支持的转换形式。java支持多实现。<br>1，类可以实现多个接口，用关健字：implements 如：<br>class Test implements JieKou,JieKou2<br>2，类继承后，仍可以实现多个接口，如：<br>class Test extends Demoimplements JieKou,JieKou2<br>3，接口在可以实现多继承,如：<br>interface Test extends A,B</p><p>（三） 多态<br>1，多态的体现<br>父类的引用指向了自己的子类对象。<br>父类的引用也可以接收自己的子类对象。<br>2，多态的前提<br>必须是类与类之间有关系。要么继承，要么实现。<br>通常还有一个前提：存在覆盖。</p><p>3，多态的好处<br>多态的出现大大的提高程序的扩展性。</p><p>4，多态的弊端：<br>提高了扩展性，但是只能使用父类的引用访问父类中的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract classAnimal&#123;</span><br><span class="line">       abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"> //多态还有一个前提：存在覆盖。不然没有意义，只是继承了一个空方法。</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  public void eat()&#123;</span><br><span class="line">              System.out.println(&quot;吃鱼&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">//但是只能使用父类的引用访问父类中的成员。因为父类中并没有catchMouse方法，所以多态无法实现catchMouse</span><br><span class="line">public void catchMouse()&#123;</span><br><span class="line">      System.out.println(&quot;抓老鼠&quot;);</span><br><span class="line">&#125;</span><br><span class="line">class Dog extendsAnimal&#123;</span><br><span class="line">       public void eat()&#123;</span><br><span class="line">              System.out.println(&quot;吃骨头&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public static voidfunction(Animal a)//Animal a = new Cat();父类的引用指向了自己的子类对象。父类的引用也可以接收自己的子类对象。<br>前题：必须是类与类之间有关系。要么继承，要么实现。Animal是动物，Cat是它的子类。<br>{<br>       a.eat();<br>}<br>class DuoTaiDemo {<br>       public static void main(String[] args){<br>              function(new Cat());<br>              function(new Dog());//提高了扩展性，不用再去新建一个对象，再引用对象的功能。<br>       }<br>异常：<br>1.异常的处理</p><p>public static voidfunction(Animal a)//Animal a = new Cat();父类的引用指向了自己的子类对象。父类的引用也可以接收自己的子类对象。<br>前题：必须是类与类之间有关系。要么继承，要么实现。Animal是动物，Cat是它的子类。<br>{<br>       a.eat();<br>}<br>class DuoTaiDemo<br>{<br>       public static void main(String[] args)<br>       {<br>              function(new Cat());<br>function(new Dog());//提高了扩展性，不用再去新建一个对象，再引用对象的功能。<br>       }<br>异常：<br>1.异常的处理</p><p>java 提供了特有的固定语句进行处理。<br>try<br>{<br>       需要被检测的代码；<br>}<br>catch(异常类 变量)<br>{<br>       处理异常的代码；(处理方式)<br>}<br>finally//这句可以没有。<br>{<br>2.对捕获到的异常对象进行常见方法操作。</p><p> StringgetMessage()：获取异常信息。</p><p>在函数上声明异常。<br>便于提高安全性，让调用出进行处理。不处理编译失败<br>对多异常的处理。</p><p>1，声明异常时，建议声明更为具体的异常。这样处理的可以更具体。<br>2，对方声明几个异常，就对应有几个catch块。不要定义多余的catch块。<br>如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面。</p><p>建立在进行catch处理时，catch中一定要定义具体处理方式。<br>不要简单定义一句 e.printStackTrace(),<br>也不要简单的就书写一条输出语句。</p><p>自定义异常：<br>必须是自定义类继承Exception，因为异常体系有一个特点就是异常类和异常对象都被抛出，他们要具备可抛性，而这个可抛性是Throwable这个体系中独有特点。<br>只有这个体系中的类和对象才可以被throws和throw操作，二者区别是：<br>throws使用在函数上用，用来抛出异常，告诉调用者这里有可能会出现异常。throw使用在函数内用来抛出异常对象让调用者处理。<br>throws后面跟的异常类。可以跟多个。用逗号隔开。<br>throw后跟的是异常对象。</p><p>Exceptoin中有一个特殊的子类异常RuntimeException：运行时异常。<br>如果在函数内容抛出该异常，函数上可以不用声明，编译一样通过。<br>如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过；</p><p>之所以不用在函数声明，是因为不需要让调用者处理，当该异常发生，希望程序停止，<br>对代码进行修正。<br>自定义异常时，如果该异常的发生，无法处理让其再继续进行运算，必须修正代码，就让自定义异常继承RuntimeException，如可以处理，则继承Exception。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/10/17/hello-world/"/>
    <url>2019/10/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>